'''
    File name: bomManager.py
    Author: Huzaifa Ahmad
    Date created: 10/11/2021
    Date last modified: 10/11/2021
    Python Version: 3.9.1
    ===============================
    This program is used to generate a digital and DCDC subBoM from the main radio board BoM.
    This script will also combine the current MPC BoM with the digital BoM in the case that the MPC will be built as a combined entity with the dig cutout board
    To use this script have ht
    ===============================
'''

# used to combine parsed BoM data and convert to csv
import pandas as pd
# used to read csv generated by Cadence
import csv

from bomComparator import BomComparator
# import BomComparator

# Each row of an Cadence CSV is in the following format:

# 0         1       2          3   4           5           6      7            8
# Part Name,Ref Des,Var Status,Qty,PART_NUMBER,DESCRIPTION,MFG_PN,MANUFACTURER,PRT_NUMBER


class BomManager:
    def __init__(self, radioBoM, mpcBoM):
        # defining BoM paths
        self.radioBoM = radioBoM
        self.mpcBoM = mpcBoM
        self.dcdcBoMFileName = "Gen BoM\DCDC_BOM.csv"
        self.digBoMFileName = "Gen BoM\Dig_BOM.csv"
        self.DIGandMPCFileName = "Gen BoM\Combined_Dig_and_MPC_BOM.csv"
        self.parseRadioBoM()
        self.parseMPCBoM()

    def parseRadioBoM(self):
        with open(self.radioBoM, 'r') as rBoM:
            for _ in range(7):
                next(rBoM)

            BoMHeader = rBoM.readline()
            # removing trailing new line char and converting header string to list to use as columns name
            BoMHeader = BoMHeader.rstrip("\n").split(',')

            # rBoMData is a list of lists: each list is a line in the BoM csv
            rBoMData = []
            # parsing through rBoM line by line extracting info and appending to list of lists holding bom info in order
            for cLine in csv.reader(rBoM, quotechar='"', delimiter=','):
                if cLine[0] != 'TOTAL':
                    rBoMData.append(cLine)

            # creating DF with parsed data and header and making data accessible to all methods
            self.BoMHeader = BoMHeader
            self.rBoMData = rBoMData
            radioDF = pd.DataFrame(rBoMData, columns=BoMHeader)
            self.radioDF = radioDF

    def parseMPCBoM(self):
        with open(self.mpcBoM, 'r') as mBoM:
            for _ in range(8):
                next(mBoM)
            mBoMData = []
            for cLine in csv.reader(mBoM, quotechar='"', delimiter=','):
                if (cLine[0] != 'TOTAL'):
                    mBoMData.append(cLine)

            # making MPC BoM data accessible to all methods
            self.mpcBoMData = mBoMData

    def createSubBoM(self):
        # using a list to track parts since growiing a DF is extremely slow, ref des suffix defined for corresponding BoM
        dcdcBoMData = []
        DCDCsuffix = '_DC0'

        digBoMData = []
        DIGsuffixes = ['_CG', '_DC1', '_DIG0']

        for row in self.rBoMData:
            # using a filter function to get a list of each parts refdes
            digPartRefDes = list(filter(lambda refdes: (any(refdes.endswith(
                digSuffix) for digSuffix in DIGsuffixes)), row[1].split(',')))
            dcdcPartRefDes = list(filter(lambda refdes: (
                refdes.endswith(DCDCsuffix)), row[1].split(',')))

            if len(digPartRefDes):
                digRow = row
                digRow[1] = ', '.join(digPartRefDes)
                digRow[3] = len(digPartRefDes)
                digBoMData.append(digRow)

            elif len(dcdcPartRefDes):
                dcdcRow = row
                dcdcRow[1] = ', '.join(dcdcPartRefDes)
                dcdcRow[3] = len(dcdcPartRefDes)
                dcdcBoMData.append(dcdcRow)

        dcdcBoMData = self.removeDupes(dcdcBoMData)
        digBoMData = self.removeDupes(digBoMData)

        # creating DCDC and Dig DFs
        dcdcDF = pd.DataFrame(dcdcBoMData, columns=self.BoMHeader)
        digDF = pd.DataFrame(digBoMData, columns=self.BoMHeader)

        self.dcdcDF = dcdcDF
        self.dcdcBoMData = dcdcBoMData
        self.digDF = digDF
        self.digBoMData = digBoMData

    def removeDupes(self, BoMData):
        # this loop iterates through the passed through BoM and replaces the duplicate DPN rows with empty rows
        for i in range(0, len(BoMData)-1):
            currDPN = BoMData[i][4]
            for j in range(i+1, len(BoMData)):
                nextDPN = BoMData[j][4]
                if (currDPN != None and currDPN == nextDPN):
                    BoMData[i][1] += ',' + BoMData[j][1]
                    BoMData[i][3] = str(
                        int(BoMData[i][3]) + int(BoMData[j][3]))
                    for rowIndex in range(0, len(BoMData[j])):
                        BoMData[j][rowIndex] = None

        # this loop deletes empty rows and try catch is used to catch IndexOutofBoundError that occurs when iteratively deleting items through a list
        for row in range(0, len(BoMData)):
            try:
                if BoMData[row][0] == None:
                    BoMData.pop(row)
            except IndexError as error:
                pass
        return BoMData

    # 0         1       2          3   4           5           6      7            8
    # Part Name,Ref Des,Var Status,Qty,PART_NUMBER,DESCRIPTION,MFG_PN,MANUFACTURER,PRT_NUMBER
    def combineMPCandDig(self):
        digDataCopy = self.digBoMData
        mpcDataCopy = self.mpcBoMData

        # this counter var is used to keep track of the current MPC row. Once a duplicate row has been combined in the BoM the 2nd instance of the duplicate needs to be deleted
        for digRow in digDataCopy:
            for mpcRow in mpcDataCopy:
                # the value at [4] is the component DPN, here comparing the two to combine duplicates within the two BoMs
                if digRow[4] == mpcRow[4]:
                    digRow[1] += ',' + mpcRow[1]
                    digRow[3] = str(int(digRow[3]) + int(mpcRow[3]))
                    mpcDataCopy.remove(mpcRow)

        digDataCopy.extend(mpcDataCopy)
        DIGandMPCDF = pd.DataFrame(digDataCopy, columns=self.BoMHeader)
        self.DIGandMPCData = digDataCopy
        self.DIGandMPCDF = DIGandMPCDF

    def createCSV(self):
        self.dcdcDF.to_csv(self.dcdcBoMFileName, encoding='utf-8', index=False)
        print("DCDC BoM Produced!")
        self.digDF.to_csv(self.digBoMFileName, encoding='utf-8', index=False)
        print("Digital BoM Produced!")
        self.DIGandMPCDF.to_csv(self.DIGandMPCFileName,
                                encoding='utf-8', index=False)
        print("Combined Digital & MPC Produced!")

    def printDFs(self):
        print("Radio BoM")
        print(self.radioDF)
        print("DCDC BoM")
        print(self.dcdcDF)
        print("Dig BoM")
        print(self.digDF)
        print("Dig & MPC BoM")
        print(self.DIGandMPCDF)

    def compareBoMs(self):
        newDigBoM = self.digDF.values.tolist()
        oldDigBoM = pd.read_csv(
            'Gen BoM\last wk\Dig_BOM_OLD.txt').values.tolist()

        # newDCDCBoM = self.dcdcDF.values.tolist()
        # oldDCDCBoM = pd.read_csv(
        # 'Gen BoM\last wk\DCDC_BOM_OLD.txt').values.tolist()

        newMPCBoM = self.mpcBoMData
        oldMPCBoM = pd.read_csv(
            'Gen BoM\last wk\MPC_BOM_OLD.txt').values.tolist()

        self.DigBoMComparator = BomComparator(oldDigBoM, newDigBoM, 'Digital')
        # self.DCDCBoMComparator = BomComparator(oldDCDCBoM, newDCDCBoM, 'DCDC')
        self.MPCBoMComparaator = BomComparator(oldMPCBoM, newMPCBoM, 'MPC')


# Name of BoMs here
bomGen = BomManager("v297n.txt", "maintenance_port_card_variant0.txt")
bomGen.createSubBoM()
bomGen.createCSV()
bomGen.compareBoMs()
